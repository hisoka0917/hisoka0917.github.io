<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-12-19T17:52:38+08:00</updated><id>http://localhost:4000/</id><title type="html">Hisoka Blog</title><subtitle>I'm an iOS developer. 5+ years Objective-C experience. Using Swift now.  Know React and Hybrid Develop. Want to learn more.</subtitle><author><name>Hisoka</name></author><entry><title type="html">gitlab自动备份</title><link href="http://localhost:4000/git/2017/12/19/gitlab-backup.html" rel="alternate" type="text/html" title="gitlab自动备份" /><published>2017-12-19T16:50:11+08:00</published><updated>2017-12-19T16:50:11+08:00</updated><id>http://localhost:4000/git/2017/12/19/gitlab-backup</id><content type="html" xml:base="http://localhost:4000/git/2017/12/19/gitlab-backup.html">&lt;p&gt;#gitlab 自动备份&lt;/p&gt;

&lt;p&gt;近日由于需要做了一下gitlab的自动备份。总的方法是挂载一个共享目录，将gitlab的备份目录改到该共享目录，并使用crontab来实现每日自动备份。&lt;/p&gt;

&lt;h4 id=&quot;挂载共享目录&quot;&gt;挂载共享目录&lt;/h4&gt;

&lt;p&gt;目前的情况是这样的，服务器是在一台Windows Server上，用Hyper-V创建的Linux虚拟机，gitlab搭建在虚拟机里。Windows Server上有一块硬盘作为NAS。我的想法是在NAS上创建一个共享目录，然后把这个目录挂载到Linux上。gitlab支持NFS/CIFS/SMB等协议的共享目录备份。
首先在Windows上设置好共享目录，然后分配好用户和访问权限。然后到Linux里面编辑&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/fstab&lt;/code&gt;文件，添加以下一行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;\\192.168.1.62\share-dir /mnt/backups cifs credentials=/root/secret.txt,uid=git,gid=git 0 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;secret.txt&lt;/code&gt;的内容为拥有共享目录访问权限的用户名和密码，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;username=gitlab
password=123456
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这行代码的意思是使用cifs协议，将&lt;code class=&quot;highlighter-rouge&quot;&gt;\\192.168.1.62\share-dir&lt;/code&gt;文件夹挂载到&lt;code class=&quot;highlighter-rouge&quot;&gt;/mnt/backups&lt;/code&gt;上。访问该路径的用户信息在&lt;code class=&quot;highlighter-rouge&quot;&gt;secret.txt&lt;/code&gt;里面，并且赋予git用户的权限。&lt;/p&gt;

&lt;p&gt;保存以后运行&lt;code class=&quot;highlighter-rouge&quot;&gt;mount -a&lt;/code&gt;挂载目录。写在&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/fstab&lt;/code&gt;里的好处是每次开机重启后会自动挂载。&lt;/p&gt;

&lt;h4 id=&quot;修改gitlab备份路径&quot;&gt;修改gitlab备份路径&lt;/h4&gt;

&lt;p&gt;编辑&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/gitlab/gitlab.rb&lt;/code&gt;文件，添加如下内容：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;n&quot;&gt;gitlab_rails&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'backup_upload_connection'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;br data-jekyll-commonmark-ghpages=&quot;&quot; /&gt;  &lt;span class=&quot;ss&quot;&gt;:provider&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Local'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;br data-jekyll-commonmark-ghpages=&quot;&quot; /&gt;  &lt;span class=&quot;ss&quot;&gt;:local_root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'/mnt/backups'&lt;/span&gt;&lt;br data-jekyll-commonmark-ghpages=&quot;&quot; /&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;br data-jekyll-commonmark-ghpages=&quot;&quot; /&gt;&lt;br data-jekyll-commonmark-ghpages=&quot;&quot; /&gt;&lt;span class=&quot;c1&quot;&gt;# The directory inside the mounted folder to copy backups to&lt;/span&gt;&lt;br data-jekyll-commonmark-ghpages=&quot;&quot; /&gt;&lt;span class=&quot;c1&quot;&gt;# Use '.' to store them in the root directory&lt;/span&gt;&lt;br data-jekyll-commonmark-ghpages=&quot;&quot; /&gt;&lt;span class=&quot;n&quot;&gt;gitlab_rails&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'backup_upload_remote_directory'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'gitlab_backups'&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;gitlab生成的备份文件访问权限为owner/group是git:git并且访问权限是0600，如果想要修改生成备份文件的访问权限，就添加以下内容：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;c1&quot;&gt;# In /etc/gitlab/gitlab.rb, for omnibus packages&lt;/span&gt;&lt;br data-jekyll-commonmark-ghpages=&quot;&quot; /&gt;&lt;span class=&quot;n&quot;&gt;gitlab_rails&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'backup_archive_permissions'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mo&quot;&gt;0644&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# Makes the backup archives world-readable&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;如果想要让gitlab自动清理旧的备份，添加如下内容：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;c1&quot;&gt;# limit backup lifetime to 7 days - 604800 seconds&lt;/span&gt;&lt;br data-jekyll-commonmark-ghpages=&quot;&quot; /&gt;&lt;span class=&quot;n&quot;&gt;gitlab_rails&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'backup_keep_time'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;604800&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;编辑完成后执行&lt;code class=&quot;highlighter-rouge&quot;&gt;gitlab-ctl reconfigure&lt;/code&gt;让配置生效。&lt;/p&gt;

&lt;h4 id=&quot;使用crontab执行每日自动备份&quot;&gt;使用crontab执行每日自动备份&lt;/h4&gt;

&lt;p&gt;执行&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo crontab -e -u root&lt;/code&gt;编辑crontab。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0 3 * * 2-6  umask 0077; tar cfz /mnt/backups/gitlab-backups/$(date &quot;+etc-gitlab-\%s.tgz&quot;) -C / etc/gitlab
0 4 * * * /opt/gitlab/bin/gitlab-rake gitlab:backup:create CRON=1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第一行是说在每周2到周6的3点钟备份&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/gitlab&lt;/code&gt;目录。该目录下存放着gitlab的配置文件，用户的二次验证信息等。gitlab官方推荐备份整个文件夹。
第二行意思是在每天4点使用gitlab本身的备份命令备份整个应用。&lt;code class=&quot;highlighter-rouge&quot;&gt;CRON=1&lt;/code&gt;表示如果没有错误就不输出进度，这样会减少cron的垃圾信息，推荐加上该参数。&lt;/p&gt;</content><author><name>Hisoka</name></author><summary type="html">#gitlab 自动备份</summary></entry><entry><title type="html">Swift中的可选类型?和隐式解析可选类型!</title><link href="http://localhost:4000/swift/2017/10/17/swift-implicitly-unwrapped-optionals.html" rel="alternate" type="text/html" title="Swift中的可选类型?和隐式解析可选类型!" /><published>2017-10-17T19:15:00+08:00</published><updated>2017-10-17T19:15:00+08:00</updated><id>http://localhost:4000/swift/2017/10/17/swift-implicitly-unwrapped-optionals</id><content type="html" xml:base="http://localhost:4000/swift/2017/10/17/swift-implicitly-unwrapped-optionals.html">&lt;h1 id=&quot;swift中的可选类型和隐式解析可选类型&quot;&gt;Swift中的可选类型&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;和隐式解析可选类型&lt;code class=&quot;highlighter-rouge&quot;&gt;!&lt;/code&gt;&lt;/h1&gt;

&lt;h3 id=&quot;可选类型&quot;&gt;可选类型&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;开发中经常会需要处理变量值为空的情况，Swift作为一种类型安全的语言很重视值为空的情况。于是引入了可选类型。
可选类型的值可能有值，也可能为空值。所以必须要处理可能为空值&lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;时的情况&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;possibleString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;actualString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;possibleString&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// actualString是普通（非可选）字符串，其值与possibleString中的值相同&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;actualString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;//输出&quot;Hello\n&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// possibleString为空值时的情况&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可选类型的值是可选值，这在字符串类型中需要特别注意&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;possibleString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello&quot;&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;possibleString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//编译器会提示“Expression implicitly coerced from 'String?' to Any”；&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 此时打印出来的值是&quot;Optional(&quot;Hello&quot;)&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如上例所示，如果直接使用可选字符串，那么值将会包含在&lt;code class=&quot;highlighter-rouge&quot;&gt;Optional(&quot;&quot;)&lt;/code&gt;中。此时就需要使用强制解析符号&lt;code class=&quot;highlighter-rouge&quot;&gt;!&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;possibleString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello&quot;&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;possibleString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// &quot;Hello\n&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;使用可选类型可以让代码更加严谨，并且在每个使用的地方强迫你去思考这里是否可能为空。&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 应用场景&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 错误写法: let url: URL = URL(string: &quot;http://www.baidu.com&quot;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 因为URL的构造函数可能会失败，所以它的返回值是URL?类型&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 正确写法: let url: URL? = URL(string: &quot;http://www.baidu.com&quot;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 使用类型推导&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;http://www.baidu.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/* 不推荐写法
if url != nil {
    URLRequest(url: url!)
}
*/&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 该语法称为可选绑定（如果url有值就解包赋值给tempUrl，并执行{}）&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;tempUrl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;URLRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tempUrl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;隐式解析可选类型&quot;&gt;隐式解析可选类型&lt;/h3&gt;
&lt;p&gt;如上所示，可选类型在使用中需要判断是否为空值，那么这就带来一个问题：怎么确定一个可选类型是有值的呢？
比如像这样&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;dog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;wangcai&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;cat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dog&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// Error: Value of optional type 'String?' not unwrapped; did you mean to use '!' or '?'?&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如上，变量cat在接受赋值时无法确定dog是不是nil，因为它是可选类型，所以编译器报错。
所以，就像上文所说使用强制解析&lt;code class=&quot;highlighter-rouge&quot;&gt;!&lt;/code&gt;来表示我有值。或者cat也声明为可选类型&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;dog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;wangcai&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;cat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dog&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;为了省心，我们使用强制解析&lt;code class=&quot;highlighter-rouge&quot;&gt;!&lt;/code&gt;，但是以下情况就不省心了&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;dog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;wangcai&quot;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//dog变量想要给一个非可选类型的cat变量赋值&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;cat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dog&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;//cat说，嗯，我已经拿到啦，么么哒！&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;tiger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dog&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;//hello，我是旺财～&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;fish&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dog&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;//我是旺财～&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;bird&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dog&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;//旺财。。。&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;sheep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dog&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;//为什么每次都得验证一遍&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;mouse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dog&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;//心好累&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;为了不出现满屏的&lt;code class=&quot;highlighter-rouge&quot;&gt;!&lt;/code&gt;，我们可以采用隐式解析可选类型&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;dog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;wangcai&quot;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//dog变量想要给一个非可选类型的cat变量赋值&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;cat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dog&lt;/span&gt;           &lt;span class=&quot;c1&quot;&gt;//cat说，嗯，我已经拿到啦，么么哒！&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;tiger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dog&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;//ok&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;fish&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dog&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;//ok&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;bird&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dog&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;//ok&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;sheep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dog&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;//ok&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;mouse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dog&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;//ok&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;看，将dog声明为隐式解析可选类型&lt;code class=&quot;highlighter-rouge&quot;&gt;String!&lt;/code&gt;省去了满世界的&lt;code class=&quot;highlighter-rouge&quot;&gt;!&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;那么我们是否一直使用隐式解析可选类型就万事大吉了呢？答案是&lt;em&gt;No&lt;/em&gt;。因为隐式解析可选类型还是可选类型，它是可以为空的。如果在空值时被使用，程序就会&lt;strong&gt;Crash&lt;/strong&gt;。&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;www.baidu.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// nothing happened&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;URLRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// fatal error: unexpectedly found nil while unwrapping an Optional value&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;什么时候使用隐式解析可选类型&quot;&gt;什么时候使用隐式解析可选类型？&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;初始化过程中不能定义的常量&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;每一个成员常量在初始化完成后一定会有一个值。然而有的时候在初始化过程中不能确定会有正确的值，但是又可以确保在被访问前一定会有值。&lt;br /&gt;
使用可选变量不会有问题，因为可选变量在初始化时会自动被赋予&lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;，并且在初始化结束时被赋予正确的值。但是使用时的强制解包会很痛苦，满屏幕都会是&lt;code class=&quot;highlighter-rouge&quot;&gt;!&lt;/code&gt;。&lt;br /&gt;
以下展示了一个成员变量在视图加载完成之前不能完成初始化的例子：&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyController&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIViewController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;@IBOutlet&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIButton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;buttonOriginalWidth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;CGFloat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buttonOriginalWidth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里有2个隐式解析可选类型。IBOutlet类型是Xcode强制为可选类型的，因为它不是在初始化时赋值的，而是在加载视图的时候。你可以把它设置为普通可选类型，但是如果这个视图加载正确，它是不会为空的。&lt;br /&gt;
在视图加载完成之前，我们无法知道button的初始宽度。但是我们知道&lt;code class=&quot;highlighter-rouge&quot;&gt;viewDidLoad&lt;/code&gt;方法会在任何方法之前被调用（除了初始化函数）。与其在所有地方强制解包，不如定义成隐式解析可选类型。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当程序不能在某个变量为&lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;后恢复
这种情况非常罕见。如果应用程序在访问某个空的变量时无法继续运行，那么也就无需再判空了。通常情况下，如果程序必须符合某个条件才能继续运行，则可以使用断言。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;什么时候不使用隐式解析可选类型&quot;&gt;什么时候不使用隐式解析可选类型？&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;延迟加载计算类型成员
有时候我们需要永远不为空的成员变量，但是它可能在初始化时不能被正确赋值。一种方法是使用隐式解析可选类型。不过更好的方法是使用延迟加载：&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;FileSystemItem&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Directory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;FileSystemItem&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;lazy&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;contents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;FileSystemItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;loadedContents&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;FileSystemItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]()&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// load contents and append to loadedContents&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loadedContents&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如上代码所示，&lt;code class=&quot;highlighter-rouge&quot;&gt;contents&lt;/code&gt;不会被初始化直到它第一次被访问。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;另外任何地方
在大多数情况下，要避免使用隐式解析可选类型，因为一旦使用错误就会造成程序&lt;strong&gt;Crash&lt;/strong&gt;。如果不确定一个变量是否会是&lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;，就默认使用普通可选类型。去解包一个不会是&lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;的变量不会有什么副作用。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://drewag.me/posts/2014/07/05/uses-for-implicitly-unwrapped-optionals-in-swift&quot;&gt;an drewagner: Uses for Implicitly Unwrapped Optionals in Swift&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/6f74174ff81f&quot;&gt;Liwx: Swift可选类型&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/3a2f66be4399&quot;&gt;民谣程序员：Swift- 可选类型，隐式解析可选类型&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Hisoka</name></author><summary type="html">Swift中的可选类型?和隐式解析可选类型!</summary></entry></feed>